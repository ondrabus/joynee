{
  "version": 3,
  "sources": ["../../../../../../../../private/var/folders/9m/ny6r8sc577v_0kqt19mty_hc0000gq/T/tmpoafs_rp6/src/authorizer.ts", "../../../../../../../../private/var/folders/9m/ny6r8sc577v_0kqt19mty_hc0000gq/T/tmpoafs_rp6/node_modules/aws-jwt-verify/dist/esm/error.js", "../../../../../../../../private/var/folders/9m/ny6r8sc577v_0kqt19mty_hc0000gq/T/tmpoafs_rp6/node_modules/aws-jwt-verify/dist/esm/node-web-compat-node.js", "../../../../../../../../private/var/folders/9m/ny6r8sc577v_0kqt19mty_hc0000gq/T/tmpoafs_rp6/node_modules/aws-jwt-verify/dist/esm/https-node.js", "../../../../../../../../private/var/folders/9m/ny6r8sc577v_0kqt19mty_hc0000gq/T/tmpoafs_rp6/node_modules/aws-jwt-verify/dist/esm/https.js", "../../../../../../../../private/var/folders/9m/ny6r8sc577v_0kqt19mty_hc0000gq/T/tmpoafs_rp6/node_modules/aws-jwt-verify/dist/esm/safe-json-parse.js", "../../../../../../../../private/var/folders/9m/ny6r8sc577v_0kqt19mty_hc0000gq/T/tmpoafs_rp6/node_modules/aws-jwt-verify/dist/esm/assert.js", "../../../../../../../../private/var/folders/9m/ny6r8sc577v_0kqt19mty_hc0000gq/T/tmpoafs_rp6/node_modules/aws-jwt-verify/dist/esm/jwk.js", "../../../../../../../../private/var/folders/9m/ny6r8sc577v_0kqt19mty_hc0000gq/T/tmpoafs_rp6/node_modules/aws-jwt-verify/dist/esm/jwt.js", "../../../../../../../../private/var/folders/9m/ny6r8sc577v_0kqt19mty_hc0000gq/T/tmpoafs_rp6/node_modules/aws-jwt-verify/dist/esm/jwt-verifier.js", "../../../../../../../../private/var/folders/9m/ny6r8sc577v_0kqt19mty_hc0000gq/T/tmpoafs_rp6/node_modules/aws-jwt-verify/dist/esm/cognito-verifier.js"],
  "sourcesContent": ["import { CognitoJwtVerifier } from \"aws-jwt-verify\";\nimport { APIGatewayRequestAuthorizerHandler } from \"aws-lambda\";\n\nconst UserPoolId = process.env.USER_POOL_ID!;\nconst AppClientId = process.env.APP_CLIENT_ID!;\n\nexport const handler: APIGatewayRequestAuthorizerHandler = async (event, context) => {\n  try {\n    let encodedToken: string | undefined\n    \n    if (event?.headers && (event.headers?.Authorization || event.headers?.authorization)){\n      const authHeader = (event.headers?.Authorization || event.headers?.authorization || \"\")\n      encodedToken = authHeader.replace(\"Bearer \", \"\")\n    } else {\n      encodedToken = event.queryStringParameters?.idToken || \"\"\n    }\n\n    if (!encodedToken){ \n      console.log(\"Token was not found\")\n      return denyAllPolicy()\n    }\n    \n    const verifier = CognitoJwtVerifier.create({\n      userPoolId: UserPoolId,\n      tokenUse: \"id\",\n      clientId: AppClientId,\n    });\n\n    const payload = await verifier.verify(encodedToken)\n    console.log(\"Token is valid. Payload:\", payload)\n    console.log(\"Event\", event)\n    \n    return allowPolicy(event.methodArn, payload)\n  } catch (error: any) {\n    console.log(error.message)\n    return denyAllPolicy()\n  }\n};\n\nconst denyAllPolicy = () => {\n  return {\n    principalId: \"*\",\n    policyDocument: {\n      Version: \"2012-10-17\",\n      Statement: [\n        {\n          Action: \"*\",\n          Effect: \"Deny\",\n          Resource: \"*\",\n        } as const,\n      ],\n    },\n  };\n};\n\nconst allowPolicy = (methodArn: string, idToken: any) => {\n  return {\n    principalId: idToken.sub,\n    policyDocument: {\n      Version: \"2012-10-17\",\n      Statement: [\n        {\n          Action: \"execute-api:Invoke\",\n          Effect: \"Allow\",\n          Resource: methodArn,\n        } as const,\n      ],\n    },\n    context: {\n      // set userId in the context\n      userId: idToken.sub,\n    },\n  };\n};", "// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n/**\n * Base Error for all other errors in this file\n */\nexport class JwtBaseError extends Error {\n}\n/**\n * An error that is raised because an actual value does not match with the expected value\n */\nexport class FailedAssertionError extends JwtBaseError {\n    constructor(msg, actual, expected) {\n        super(msg);\n        this.failedAssertion = {\n            actual,\n            expected,\n        };\n    }\n}\n/**\n * JWT errors\n */\nexport class JwtParseError extends JwtBaseError {\n    constructor(msg, error) {\n        const message = error != null ? `${msg}: ${error}` : msg;\n        super(message);\n    }\n}\nexport class ParameterValidationError extends JwtBaseError {\n}\nexport class JwtInvalidSignatureError extends JwtBaseError {\n}\nexport class JwtInvalidSignatureAlgorithmError extends FailedAssertionError {\n}\nexport class JwtInvalidClaimError extends FailedAssertionError {\n    withRawJwt({ header, payload }) {\n        this.rawJwt = {\n            header,\n            payload,\n        };\n        return this;\n    }\n}\nexport class JwtInvalidIssuerError extends JwtInvalidClaimError {\n}\nexport class JwtInvalidAudienceError extends JwtInvalidClaimError {\n}\nexport class JwtInvalidScopeError extends JwtInvalidClaimError {\n}\nexport class JwtExpiredError extends JwtInvalidClaimError {\n}\nexport class JwtNotBeforeError extends JwtInvalidClaimError {\n}\n/**\n * Amazon Cognito specific erros\n */\nexport class CognitoJwtInvalidGroupError extends JwtInvalidClaimError {\n}\nexport class CognitoJwtInvalidTokenUseError extends JwtInvalidClaimError {\n}\nexport class CognitoJwtInvalidClientIdError extends JwtInvalidClaimError {\n}\n/**\n * JWK errors\n */\nexport class JwksValidationError extends JwtBaseError {\n}\nexport class JwkValidationError extends JwtBaseError {\n}\nexport class JwtWithoutValidKidError extends JwtBaseError {\n}\nexport class KidNotFoundInJwksError extends JwtBaseError {\n}\nexport class WaitPeriodNotYetEndedJwkError extends JwtBaseError {\n}\nexport class JwksNotAvailableInCacheError extends JwtBaseError {\n}\nexport class JwkInvalidUseError extends FailedAssertionError {\n}\nexport class JwkInvalidKtyError extends FailedAssertionError {\n}\n/**\n * HTTPS fetch errors\n */\nexport class FetchError extends JwtBaseError {\n    constructor(uri, msg) {\n        super(`Failed to fetch ${uri}: ${msg}`);\n    }\n}\nexport class NonRetryableFetchError extends FetchError {\n}\n/**\n * Web compatibility errors\n */\nexport class NotSupportedError extends JwtBaseError {\n}\n", "// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n//\n// Node.js implementations for the node-web-compatibility layer\nimport { createPublicKey, createVerify, verify } from \"crypto\";\nimport { fetch } from \"./https-node.js\";\n/**\n * Enum to map supported JWT signature algorithms with OpenSSL message digest algorithm names\n */\nvar JwtSignatureAlgorithmHashNames;\n(function (JwtSignatureAlgorithmHashNames) {\n    JwtSignatureAlgorithmHashNames[\"RS256\"] = \"RSA-SHA256\";\n    JwtSignatureAlgorithmHashNames[\"RS384\"] = \"RSA-SHA384\";\n    JwtSignatureAlgorithmHashNames[\"RS512\"] = \"RSA-SHA512\";\n    JwtSignatureAlgorithmHashNames[\"ES256\"] = \"RSA-SHA256\";\n    JwtSignatureAlgorithmHashNames[\"ES384\"] = \"RSA-SHA384\";\n    JwtSignatureAlgorithmHashNames[\"ES512\"] = \"RSA-SHA512\";\n})(JwtSignatureAlgorithmHashNames || (JwtSignatureAlgorithmHashNames = {}));\nexport const nodeWebCompat = {\n    fetch,\n    transformJwkToKeyObjectSync: (jwk) => createPublicKey({\n        key: jwk,\n        format: \"jwk\",\n    }),\n    transformJwkToKeyObjectAsync: async (jwk) => createPublicKey({\n        key: jwk,\n        format: \"jwk\",\n    }),\n    parseB64UrlString: (b64) => Buffer.from(b64, \"base64\").toString(\"utf8\"),\n    verifySignatureSync: ({ alg, keyObject, jwsSigningInput, signature }) => alg !== \"EdDSA\"\n        ? // eslint-disable-next-line security/detect-object-injection\n            createVerify(JwtSignatureAlgorithmHashNames[alg])\n                .update(jwsSigningInput)\n                .verify({\n                key: keyObject,\n                dsaEncoding: \"ieee-p1363\", // Signature format r || s (not used for RSA)\n            }, signature, \"base64\")\n        : verify(null, Buffer.from(jwsSigningInput), keyObject, Buffer.from(signature, \"base64\")),\n    verifySignatureAsync: async (args) => nodeWebCompat.verifySignatureSync(args),\n    defaultFetchTimeouts: {\n        socketIdle: 1500,\n        response: 3000,\n    },\n    setTimeoutUnref: (...args) => setTimeout(...args).unref(),\n};\n", "// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n//\n// NodeJS implementation for fetching documents over HTTPS\nimport { request } from \"https\";\nimport { pipeline } from \"stream\";\nimport { FetchError, NonRetryableFetchError } from \"./error.js\";\n/**\n * Execute a HTTPS request\n * @param uri - The URI\n * @param requestOptions - The RequestOptions to use\n * @param data - Data to send to the URI (e.g. POST data)\n * @returns - The response body\n */\nexport async function fetch(uri, requestOptions, data) {\n    let responseTimeout;\n    return new Promise((resolve, reject) => {\n        const req = request(uri, {\n            method: \"GET\",\n            ...requestOptions,\n        }, (response) => {\n            // check status\n            if (response.statusCode !== 200) {\n                done(new NonRetryableFetchError(uri, `Status code is ${response.statusCode}, expected 200`));\n                return;\n            }\n            // Collect response data\n            pipeline(response, async (responseBody) => {\n                const chunks = [];\n                for await (const chunk of responseBody) {\n                    chunks.push(chunk);\n                }\n                return Buffer.concat(chunks);\n            }, done);\n        });\n        if (requestOptions?.responseTimeout) {\n            responseTimeout = setTimeout(() => done(new FetchError(uri, `Response time-out (after ${requestOptions.responseTimeout} ms.)`)), requestOptions.responseTimeout);\n            responseTimeout.unref(); // Don't block Node from exiting\n        }\n        function done(err, data) {\n            if (responseTimeout)\n                clearTimeout(responseTimeout);\n            if (err == null) {\n                resolve(data);\n                return;\n            }\n            // In case of errors, let the Agent (if any) know to abandon the socket\n            // This is probably best, because the socket may have become stale\n            /* istanbul ignore next */\n            req.socket?.emit(\"agentRemove\");\n            // Turn error into FetchError so the URI is nicely captured in the message\n            if (!(err instanceof FetchError)) {\n                err = new FetchError(uri, err.message);\n            }\n            req.destroy();\n            reject(err);\n        }\n        // Handle errors while sending request\n        req.on(\"error\", done);\n        // Signal end of request (include optional data)\n        req.end(data);\n    });\n}\n", "// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n//\n// Utilities for fetching the JWKS URI, to get the public keys with which to verify JWTs\nimport { NonRetryableFetchError } from \"./error.js\";\nimport { nodeWebCompat } from \"#node-web-compat\";\n/**\n * Execute a HTTPS request\n * @param uri - The URI\n * @param requestOptions - The RequestOptions to use (depending on the runtime context, either Node.js RequestOptions or Web Fetch init)\n * @param data - Data to send to the URI (e.g. POST data)\n * @returns - The response body as ArrayBuffer\n */\nexport const fetch = nodeWebCompat.fetch.bind(undefined);\n/**\n * HTTPS Fetcher. The fetch implementation has 1 immediate retry in case of errors\n *\n * @param defaultRequestOptions - The default RequestOptions to use on individual HTTPS requests\n *   (depending on the runtime context, either Node.js RequestOptions or Web Fetch init)\n */\nexport class SimpleFetcher {\n    constructor(props) {\n        this.defaultRequestOptions = {\n            timeout: nodeWebCompat.defaultFetchTimeouts.socketIdle,\n            responseTimeout: nodeWebCompat.defaultFetchTimeouts.response,\n            ...props?.defaultRequestOptions,\n        };\n    }\n    /**\n     * Execute a HTTPS request (with 1 immediate retry in case of errors)\n     * @param uri - The URI\n     * @param requestOptions - The RequestOptions to use (depending on the runtime context, either Node.js RequestOptions or Web Fetch init)\n     * @param data - Data to send to the URI (e.g. POST data)\n     * @returns - The response body as ArrayBuffer\n     */\n    async fetch(uri, requestOptions, data) {\n        requestOptions = { ...this.defaultRequestOptions, ...requestOptions };\n        try {\n            return await fetch(uri, requestOptions, data);\n        }\n        catch (err) {\n            if (err instanceof NonRetryableFetchError) {\n                throw err;\n            }\n            // Retry once, immediately\n            return fetch(uri, requestOptions, data);\n        }\n    }\n}\n", "// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n//\n// Utility to parse JSON safely\n/**\n * Check if a piece of JSON is a JSON object, and not e.g. a mere string or null\n *\n * @param j - the JSON\n */\nexport function isJsonObject(j) {\n    // It is not enough to check that `typeof j === \"object\"`\n    // because in JS `typeof null` is also \"object\", and so is `typeof []`.\n    // So we need to check that j is an object, and not null, and not an array\n    return typeof j === \"object\" && !Array.isArray(j) && j !== null;\n}\n/**\n * Parse a string as JSON, while removing __proto__ and constructor, so JS prototype pollution is prevented\n *\n * @param s - the string to JSON parse\n */\nexport function safeJsonParse(s) {\n    return JSON.parse(s, (_, value) => {\n        if (typeof value === \"object\" && !Array.isArray(value) && value !== null) {\n            delete value.__proto__;\n            delete value.constructor;\n        }\n        return value;\n    });\n}\n", "// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n//\n// Utilities to assert that supplied values match with expected values\nimport { FailedAssertionError } from \"./error.js\";\n/**\n * Assert value is a non-empty string and equal to the expected value,\n * or throw an error otherwise\n *\n * @param name - Name for the value being checked\n * @param actual - The value to check\n * @param expected - The expected value\n * @param errorConstructor - Constructor for the concrete error to be thrown\n */\nexport function assertStringEquals(name, actual, expected, errorConstructor = FailedAssertionError) {\n    if (!actual) {\n        throw new errorConstructor(`Missing ${name}. Expected: ${expected}`, actual, expected);\n    }\n    if (typeof actual !== \"string\") {\n        throw new errorConstructor(`${name} is not of type string`, actual, expected);\n    }\n    if (expected !== actual) {\n        throw new errorConstructor(`${name} not allowed: ${actual}. Expected: ${expected}`, actual, expected);\n    }\n}\n/**\n * Assert value is a non-empty string and is indeed one of the expected values,\n * or throw an error otherwise\n *\n * @param name - Name for the value being checked\n * @param actual - The value to check\n * @param expected - The array of expected values. For your convenience you can provide\n *   a string here as well, which will mean an array with just that string\n * @param errorConstructor - Constructor for the concrete error to be thrown\n */\nexport function assertStringArrayContainsString(name, actual, expected, errorConstructor = FailedAssertionError) {\n    if (!actual) {\n        throw new errorConstructor(`Missing ${name}. ${expectationMessage(expected)}`, actual, expected);\n    }\n    if (typeof actual !== \"string\") {\n        throw new errorConstructor(`${name} is not of type string`, actual, expected);\n    }\n    return assertStringArraysOverlap(name, actual, expected, errorConstructor);\n}\n/**\n * Assert value is an array of strings, where at least one of the strings is indeed one of the expected values,\n * or throw an error otherwise\n *\n * @param name - Name for the value being checked\n * @param actual - The value to check, must be an array of strings, or a single string (which will be treated\n * as an array with just that string)\n * @param expected - The array of expected values. For your convenience you can provide\n * a string here as well, which will mean an array with just that string\n * @param errorConstructor - Constructor for the concrete error to be thrown\n */\nexport function assertStringArraysOverlap(name, actual, expected, errorConstructor = FailedAssertionError) {\n    if (!actual) {\n        throw new errorConstructor(`Missing ${name}. ${expectationMessage(expected)}`, actual, expected);\n    }\n    const expectedAsSet = new Set(Array.isArray(expected) ? expected : [expected]);\n    if (typeof actual === \"string\") {\n        actual = [actual];\n    }\n    if (!Array.isArray(actual)) {\n        throw new errorConstructor(`${name} is not an array`, actual, expected);\n    }\n    const overlaps = actual.some((actualItem) => {\n        if (typeof actualItem !== \"string\") {\n            throw new errorConstructor(`${name} includes elements that are not of type string`, actual, expected);\n        }\n        return expectedAsSet.has(actualItem);\n    });\n    if (!overlaps) {\n        throw new errorConstructor(`${name} not allowed: ${actual.join(\", \")}. ${expectationMessage(expected)}`, actual, expected);\n    }\n}\n/**\n * Get a nicely readable message regarding an expectation\n *\n * @param expected - The expected value.\n */\nfunction expectationMessage(expected) {\n    if (Array.isArray(expected)) {\n        if (expected.length > 1) {\n            return `Expected one of: ${expected.join(\", \")}`;\n        }\n        return `Expected: ${expected[0]}`;\n    }\n    return `Expected: ${expected}`;\n}\n/**\n * Assert value is not a promise, or throw an error otherwise\n *\n * @param actual - The value to check\n * @param errorFactory - Function that returns the error to be thrown\n */\nexport function assertIsNotPromise(actual, errorFactory) {\n    if (actual && typeof actual.then === \"function\") {\n        throw errorFactory();\n    }\n}\n", "// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { SimpleFetcher, fetch } from \"./https.js\";\nimport { isJsonObject, safeJsonParse, } from \"./safe-json-parse.js\";\nimport { JwkValidationError, JwksNotAvailableInCacheError, JwksValidationError, KidNotFoundInJwksError, WaitPeriodNotYetEndedJwkError, JwtWithoutValidKidError, JwkInvalidUseError, JwkInvalidKtyError, } from \"./error.js\";\nimport { nodeWebCompat } from \"#node-web-compat\";\nimport { assertStringArrayContainsString, assertStringEquals, } from \"./assert.js\";\nconst optionalJwkFieldNames = [\n    \"use\", // https://datatracker.ietf.org/doc/html/rfc7517#section-4.2\n    \"alg\", // https://datatracker.ietf.org/doc/html/rfc7517#section-4.4\n    \"kid\", // https://datatracker.ietf.org/doc/html/rfc7517#section-4.5\n    \"n\", // https://datatracker.ietf.org/doc/html/rfc7518#section-6.3.1.1\n    \"e\", // https://datatracker.ietf.org/doc/html/rfc7518#section-6.3.1.2\n    \"x\", // https://datatracker.ietf.org/doc/html/rfc7518#section-6.2.1.2\n    \"y\", // https://datatracker.ietf.org/doc/html/rfc7518#section-6.2.1.3\n    \"crv\", //https:// datatracker.ietf.org/doc/html/rfc7518#section-6.2.1.1\n];\nconst mandatoryJwkFieldNames = [\n    \"kty\", // https://datatracker.ietf.org/doc/html/rfc7517#section-4.1\n];\nexport function findJwkInJwks(jwks, kid) {\n    return jwks.keys.find((jwk) => jwk.kid != null && jwk.kid === kid);\n}\n/**\n * UTF-8 decode binary data and then JSON parse it\n * @param jwksBin\n * @returns Jwks\n */\nconst parseJwks = function (jwksBin) {\n    let jwks;\n    try {\n        const jwksText = new TextDecoder(\"utf8\", {\n            fatal: true,\n            ignoreBOM: true,\n        }).decode(jwksBin);\n        jwks = safeJsonParse(jwksText);\n    }\n    catch (err) {\n        throw new JwksValidationError(`JWKS could not be parsed as JSON: ${err}`);\n    }\n    assertIsJwks(jwks);\n    return jwks;\n};\nexport async function fetchJwks(jwksUri) {\n    return fetch(jwksUri).then(parseJwks);\n}\nexport async function fetchJwk(jwksUri, decomposedJwt) {\n    if (!decomposedJwt.header.kid) {\n        throw new JwtWithoutValidKidError(\"JWT header does not have valid kid claim\");\n    }\n    const jwks = await fetchJwks(jwksUri);\n    const jwk = findJwkInJwks(jwks, decomposedJwt.header.kid);\n    if (!jwk) {\n        throw new KidNotFoundInJwksError(`JWK for kid \"${decomposedJwt.header.kid}\" not found in the JWKS`);\n    }\n    return jwk;\n}\nexport function assertIsJwks(jwks) {\n    if (!jwks) {\n        throw new JwksValidationError(\"JWKS empty\");\n    }\n    if (!isJsonObject(jwks)) {\n        throw new JwksValidationError(\"JWKS should be an object\");\n    }\n    if (!Object.keys(jwks).includes(\"keys\")) {\n        throw new JwksValidationError(\"JWKS does not include keys\");\n    }\n    if (!Array.isArray(jwks.keys)) {\n        throw new JwksValidationError(\"JWKS keys should be an array\");\n    }\n    for (const jwk of jwks.keys) {\n        assertIsJwk(jwk);\n    }\n}\nexport function assertIsSignatureJwk(jwk) {\n    assertStringArrayContainsString(\"JWK kty\", jwk.kty, [\"EC\", \"RSA\", \"OKP\"], JwkInvalidKtyError);\n    if (jwk.kty === \"EC\") {\n        assertIsEsSignatureJwk(jwk);\n    }\n    else if (jwk.kty === \"RSA\") {\n        assertIsRsaSignatureJwk(jwk);\n    }\n    else if (jwk.kty === \"OKP\") {\n        assertIsEdDSASignatureJwk(jwk);\n    }\n}\nfunction assertIsEdDSASignatureJwk(jwk) {\n    // Check JWK use\n    if (jwk.use) {\n        assertStringEquals(\"JWK use\", jwk.use, \"sig\", JwkInvalidUseError);\n    }\n    // Check JWK kty\n    assertStringEquals(\"JWK kty\", jwk.kty, \"OKP\", JwkInvalidKtyError);\n    // Check Curve (crv) has a value\n    if (!jwk.crv)\n        throw new JwkValidationError(\"Missing Curve (crv)\");\n    // Check X Coordinate (x) has a value\n    if (!jwk.x)\n        throw new JwkValidationError(\"Missing X Coordinate (x)\");\n}\nfunction assertIsEsSignatureJwk(jwk) {\n    // Check JWK use\n    if (jwk.use) {\n        assertStringEquals(\"JWK use\", jwk.use, \"sig\", JwkInvalidUseError);\n    }\n    // Check JWK kty\n    assertStringEquals(\"JWK kty\", jwk.kty, \"EC\", JwkInvalidKtyError);\n    // Check Curve (crv) has a value\n    if (!jwk.crv)\n        throw new JwkValidationError(\"Missing Curve (crv)\");\n    // Check X Coordinate (x) has a value\n    if (!jwk.x)\n        throw new JwkValidationError(\"Missing X Coordinate (x)\");\n    // Check Y Coordinate (y) has a value\n    if (!jwk.y)\n        throw new JwkValidationError(\"Missing Y Coordinate (y)\");\n}\nfunction assertIsRsaSignatureJwk(jwk) {\n    // Check JWK use\n    if (jwk.use) {\n        assertStringEquals(\"JWK use\", jwk.use, \"sig\", JwkInvalidUseError);\n    }\n    // Check JWK kty\n    assertStringEquals(\"JWK kty\", jwk.kty, \"RSA\", JwkInvalidKtyError);\n    // Check modulus (n) has a value\n    if (!jwk.n)\n        throw new JwkValidationError(\"Missing modulus (n)\");\n    // Check exponent (e) has a value\n    if (!jwk.e)\n        throw new JwkValidationError(\"Missing exponent (e)\");\n}\nexport function assertIsJwk(jwk) {\n    if (!jwk) {\n        throw new JwkValidationError(\"JWK empty\");\n    }\n    if (!isJsonObject(jwk)) {\n        throw new JwkValidationError(\"JWK should be an object\");\n    }\n    for (const field of mandatoryJwkFieldNames) {\n        // disable eslint rule because `field` is trusted\n        // eslint-disable-next-line security/detect-object-injection\n        if (typeof jwk[field] !== \"string\") {\n            throw new JwkValidationError(`JWK ${field} should be a string`);\n        }\n    }\n    for (const field of optionalJwkFieldNames) {\n        // disable eslint rule because `field` is trusted\n        // eslint-disable-next-line security/detect-object-injection\n        if (field in jwk && typeof jwk[field] !== \"string\") {\n            throw new JwkValidationError(`JWK ${field} should be a string`);\n        }\n    }\n}\nexport function isJwks(jwks) {\n    try {\n        assertIsJwks(jwks);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nexport function isJwk(jwk) {\n    try {\n        assertIsJwk(jwk);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nexport class SimplePenaltyBox {\n    constructor(props) {\n        this.waitingUris = new Map();\n        this.waitSeconds = props?.waitSeconds ?? 10;\n    }\n    async wait(jwksUri) {\n        // SimplePenaltyBox does not actually wait but bluntly throws an error\n        // Any waiting and retries are expected to be done upstream (e.g. in the browser / app)\n        if (this.waitingUris.has(jwksUri)) {\n            throw new WaitPeriodNotYetEndedJwkError(\"Not allowed to fetch JWKS yet, still waiting for back off period to end\");\n        }\n    }\n    release(jwksUri) {\n        const i = this.waitingUris.get(jwksUri);\n        if (i) {\n            clearTimeout(i);\n            this.waitingUris.delete(jwksUri);\n        }\n    }\n    registerFailedAttempt(jwksUri) {\n        const i = nodeWebCompat.setTimeoutUnref(() => {\n            this.waitingUris.delete(jwksUri);\n        }, this.waitSeconds * 1000);\n        this.waitingUris.set(jwksUri, i);\n    }\n    registerSuccessfulAttempt(jwksUri) {\n        this.release(jwksUri);\n    }\n}\nexport class SimpleJwksCache {\n    constructor(props) {\n        this.jwksCache = new Map();\n        this.fetchingJwks = new Map();\n        this.penaltyBox = props?.penaltyBox ?? new SimplePenaltyBox();\n        this.fetcher = props?.fetcher ?? new SimpleFetcher();\n        this.jwksParser = props?.jwksParser ?? parseJwks;\n    }\n    /**\n     * Add a JWKS to the cache explicitly. E.g. you may want to do this, if you have already downloaded the JWKS.\n     *\n     * @param jwksUri - The URI where your IDP exposes the JWKS, e.g. `https://example.com/my-idp/.well-known/jwks.json` (this is used as cache key)\n     * @param jwks - The JWKS\n     */\n    addJwks(jwksUri, jwks) {\n        this.jwksCache.set(jwksUri, jwks);\n    }\n    /**\n     * Fetch and cache the JWKS from the jwksUri\n     *\n     * @param jwksUri - The URI where your IDP exposes the JWKS, e.g. `https://example.com/my-idp/.well-known/jwks.json`\n     * @returns - The fetched jwks\n     */\n    async getJwks(jwksUri) {\n        const existingFetch = this.fetchingJwks.get(jwksUri);\n        if (existingFetch) {\n            return existingFetch;\n        }\n        const jwksPromise = this.fetcher.fetch(jwksUri).then(this.jwksParser);\n        this.fetchingJwks.set(jwksUri, jwksPromise);\n        let jwks;\n        try {\n            jwks = await jwksPromise;\n        }\n        finally {\n            this.fetchingJwks.delete(jwksUri);\n        }\n        this.jwksCache.set(jwksUri, jwks);\n        return jwks;\n    }\n    /**\n     * Get the JWKS from the cache (synchronously). Raises an error if the JWKS is not yet cached, or does not have the right JWK.\n     *\n     * @param jwksUri - The URI where your IDP exposes the JWKS, e.g. `https://example.com/my-idp/.well-known/jwks.json` (this is used as cache key)\n     * @param decomposedJwt - The decomposed JWT\n     * @returns - The previously cached JWKS\n     */\n    getCachedJwk(jwksUri, decomposedJwt) {\n        if (typeof decomposedJwt.header.kid !== \"string\") {\n            throw new JwtWithoutValidKidError(\"JWT header does not have valid kid claim\");\n        }\n        if (!this.jwksCache.has(jwksUri)) {\n            throw new JwksNotAvailableInCacheError(`JWKS for uri ${jwksUri} not yet available in cache`);\n        }\n        const jwk = findJwkInJwks(this.jwksCache.get(jwksUri), decomposedJwt.header.kid);\n        if (!jwk) {\n            throw new KidNotFoundInJwksError(`JWK for kid ${decomposedJwt.header.kid} not found in the JWKS`);\n        }\n        return jwk;\n    }\n    /**\n     * Get the right JWK to verify the JWT with. This will fetch (and cache) the JWKS in case it's not yet been cached,\n     * or if the cached JWKS doesn't have the right JWK (to account for key rotations, based on `kid`).\n     *\n     * @param jwksUri\n     * @param decomposedJwt\n     * @returns  - The JWK\n     */\n    async getJwk(jwksUri, decomposedJwt) {\n        if (typeof decomposedJwt.header.kid !== \"string\") {\n            throw new JwtWithoutValidKidError(\"JWT header does not have valid kid claim\");\n        }\n        // Try to get JWK from cache:\n        const cachedJwks = this.jwksCache.get(jwksUri);\n        if (cachedJwks) {\n            const cachedJwk = findJwkInJwks(cachedJwks, decomposedJwt.header.kid);\n            if (cachedJwk) {\n                return cachedJwk;\n            }\n        }\n        // Await any wait period that is currently in effect\n        // This prevents us from flooding the JWKS URI with requests\n        await this.penaltyBox.wait(jwksUri, decomposedJwt.header.kid);\n        // Fetch the JWKS and (try to) locate the JWK\n        const jwks = await this.getJwks(jwksUri);\n        const jwk = findJwkInJwks(jwks, decomposedJwt.header.kid);\n        // If the JWK could not be located, someone might be messing around with us\n        // Register the failed attempt with the penaltyBox, so it can enforce a wait period\n        // before trying again next time (instead of flooding the JWKS URI with requests)\n        if (!jwk) {\n            this.penaltyBox.registerFailedAttempt(jwksUri, decomposedJwt.header.kid);\n            throw new KidNotFoundInJwksError(`JWK for kid \"${decomposedJwt.header.kid}\" not found in the JWKS`);\n        }\n        else {\n            this.penaltyBox.registerSuccessfulAttempt(jwksUri, decomposedJwt.header.kid);\n        }\n        return jwk;\n    }\n}\n", "// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { assertStringArrayContainsString, assertStringArraysOverlap, } from \"./assert.js\";\nimport { safeJsonParse, isJsonObject } from \"./safe-json-parse.js\";\nimport { JwtExpiredError, JwtNotBeforeError, JwtInvalidIssuerError, JwtInvalidAudienceError, JwtInvalidScopeError, JwtParseError, ParameterValidationError, } from \"./error.js\";\nimport { nodeWebCompat } from \"#node-web-compat\";\n/**\n * Assert that the argument is a valid JWT header object.\n * Throws an error in case it is not.\n *\n * @param header\n * @returns void\n */\nfunction assertJwtHeader(header) {\n    if (!isJsonObject(header)) {\n        throw new JwtParseError(\"JWT header is not an object\");\n    }\n    if (header.alg !== undefined && typeof header.alg !== \"string\") {\n        throw new JwtParseError(\"JWT header alg claim is not a string\");\n    }\n    if (header.kid !== undefined && typeof header.kid !== \"string\") {\n        throw new JwtParseError(\"JWT header kid claim is not a string\");\n    }\n}\n/**\n * Assert that the argument is a valid JWT payload object.\n * Throws an error in case it is not.\n *\n * @param payload\n * @returns void\n */\nfunction assertJwtPayload(payload) {\n    if (!isJsonObject(payload)) {\n        throw new JwtParseError(\"JWT payload is not an object\");\n    }\n    if (payload.exp !== undefined && !Number.isFinite(payload.exp)) {\n        throw new JwtParseError(\"JWT payload exp claim is not a number\");\n    }\n    if (payload.iss !== undefined && typeof payload.iss !== \"string\") {\n        throw new JwtParseError(\"JWT payload iss claim is not a string\");\n    }\n    if (payload.sub !== undefined && typeof payload.sub !== \"string\") {\n        throw new JwtParseError(\"JWT payload sub claim is not a string\");\n    }\n    if (payload.aud !== undefined &&\n        typeof payload.aud !== \"string\" &&\n        (!Array.isArray(payload.aud) ||\n            payload.aud.some((aud) => typeof aud !== \"string\"))) {\n        throw new JwtParseError(\"JWT payload aud claim is not a string or array of strings\");\n    }\n    if (payload.nbf !== undefined && !Number.isFinite(payload.nbf)) {\n        throw new JwtParseError(\"JWT payload nbf claim is not a number\");\n    }\n    if (payload.iat !== undefined && !Number.isFinite(payload.iat)) {\n        throw new JwtParseError(\"JWT payload iat claim is not a number\");\n    }\n    if (payload.scope !== undefined && typeof payload.scope !== \"string\") {\n        throw new JwtParseError(\"JWT payload scope claim is not a string\");\n    }\n    if (payload.jti !== undefined && typeof payload.jti !== \"string\") {\n        throw new JwtParseError(\"JWT payload jti claim is not a string\");\n    }\n}\n/**\n * Sanity check, decompose and JSON parse a JWT string into its constituent, and yet unverified, parts:\n * - header object\n * - payload object\n * - signature string\n *\n * This function does NOT verify a JWT, do not trust the returned payload and header!\n *\n * For most use cases, you would not want to call this function directly yourself, rather you\n * would call verify() with the JWT, which would call this function (and others) for you.\n *\n * @param jwt The JWT (as string)\n * @returns the decomposed, and yet unverified, JWT\n */\nexport function decomposeUnverifiedJwt(jwt) {\n    // Sanity checks on JWT\n    if (!jwt) {\n        throw new JwtParseError(\"Empty JWT\");\n    }\n    if (typeof jwt !== \"string\") {\n        throw new JwtParseError(\"JWT is not a string\");\n    }\n    if (!jwt.match(/^[A-Za-z0-9_-]+={0,2}\\.[A-Za-z0-9_-]+={0,2}\\.[A-Za-z0-9_-]+={0,2}$/)) {\n        throw new JwtParseError(\"JWT string does not consist of exactly 3 parts (header, payload, signature)\");\n    }\n    const [headerB64, payloadB64, signatureB64] = jwt.split(\".\");\n    // B64 decode header and payload\n    const [headerString, payloadString] = [headerB64, payloadB64].map(nodeWebCompat.parseB64UrlString);\n    // Parse header\n    let header;\n    try {\n        header = safeJsonParse(headerString);\n    }\n    catch (err) {\n        throw new JwtParseError(\"Invalid JWT. Header is not a valid JSON object\", err);\n    }\n    assertJwtHeader(header);\n    // parse payload\n    let payload;\n    try {\n        payload = safeJsonParse(payloadString);\n    }\n    catch (err) {\n        throw new JwtParseError(\"Invalid JWT. Payload is not a valid JSON object\", err);\n    }\n    assertJwtPayload(payload);\n    return {\n        header,\n        headerB64,\n        payload,\n        payloadB64,\n        signatureB64,\n    };\n}\n/**\n * Validate JWT payload fields. Throws an error in case there's any validation issue.\n *\n * @param payload The (JSON parsed) JWT payload\n * @param options The options to use during validation\n * @returns void\n */\nexport function validateJwtFields(payload, options) {\n    // Check expiry\n    if (payload.exp !== undefined) {\n        if (payload.exp + (options.graceSeconds ?? 0) < Date.now() / 1000) {\n            throw new JwtExpiredError(`Token expired at ${new Date(payload.exp * 1000).toISOString()}`, payload.exp);\n        }\n    }\n    // Check not before\n    if (payload.nbf !== undefined) {\n        if (payload.nbf - (options.graceSeconds ?? 0) > Date.now() / 1000) {\n            throw new JwtNotBeforeError(`Token can't be used before ${new Date(payload.nbf * 1000).toISOString()}`, payload.nbf);\n        }\n    }\n    // Check JWT issuer\n    if (options.issuer !== null) {\n        if (options.issuer === undefined) {\n            throw new ParameterValidationError(\"issuer must be provided or set to null explicitly\");\n        }\n        assertStringArrayContainsString(\"Issuer\", payload.iss, options.issuer, JwtInvalidIssuerError);\n    }\n    // Check audience\n    if (options.audience !== null) {\n        if (options.audience === undefined) {\n            throw new ParameterValidationError(\"audience must be provided or set to null explicitly\");\n        }\n        assertStringArraysOverlap(\"Audience\", payload.aud, options.audience, JwtInvalidAudienceError);\n    }\n    // Check scope\n    if (options.scope != null) {\n        assertStringArraysOverlap(\"Scope\", payload.scope?.split(\" \"), options.scope, JwtInvalidScopeError);\n    }\n}\n", "// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { SimpleJwksCache, isJwk, isJwks, fetchJwk, assertIsSignatureJwk, findJwkInJwks, } from \"./jwk.js\";\nimport { assertIsNotPromise, assertStringArrayContainsString, assertStringEquals, } from \"./assert.js\";\nimport { decomposeUnverifiedJwt, validateJwtFields, } from \"./jwt.js\";\nimport { JwtInvalidClaimError, JwtInvalidSignatureAlgorithmError, JwtInvalidSignatureError, KidNotFoundInJwksError, ParameterValidationError, } from \"./error.js\";\nimport { nodeWebCompat } from \"#node-web-compat\";\nexport const supportedSignatureAlgorithms = [\n    \"RS256\",\n    \"RS384\",\n    \"RS512\",\n    \"ES256\",\n    \"ES384\",\n    \"ES512\",\n    \"EdDSA\",\n];\n/**\n * Sanity check the JWT header and the selected JWK\n *\n * @param header: the JWT header (decoded and JSON parsed)\n * @param jwk: the JWK\n */\nfunction validateJwtHeaderAndJwk(header, jwk) {\n    // Check that the JWK is in fact a JWK for signatures\n    assertIsSignatureJwk(jwk);\n    // Check that JWT signature algorithm matches JWK\n    if (jwk.alg) {\n        assertStringEquals(\"JWT signature algorithm\", header.alg, jwk.alg, JwtInvalidSignatureAlgorithmError);\n    }\n    // Check JWT signature algorithm is one of the supported signature algorithms\n    assertStringArrayContainsString(\"JWT signature algorithm\", header.alg, supportedSignatureAlgorithms, JwtInvalidSignatureAlgorithmError);\n}\n/**\n * Verify a JWT asynchronously (thus allowing for the JWKS to be fetched from the JWKS URI)\n *\n * @param jwt The JWT\n * @param jwksUri The JWKS URI, where the JWKS can be fetched from\n * @param options Verification options\n * @returns Promise that resolves to the payload of the JWT\u2013\u2013if the JWT is valid, otherwise the promise rejects\n */\nexport async function verifyJwt(jwt, jwksUri, options, jwkFetcher = fetchJwk, transformJwkToKeyObjectFn = nodeWebCompat.transformJwkToKeyObjectAsync) {\n    return verifyDecomposedJwt(decomposeUnverifiedJwt(jwt), jwksUri, options, jwkFetcher, transformJwkToKeyObjectFn);\n}\n/**\n * Verify (asynchronously) a JWT that is already decomposed (by function `decomposeUnverifiedJwt`)\n *\n * @param decomposedJwt The decomposed JWT\n * @param jwksUri The JWKS URI, where the JWKS can be fetched from\n * @param options Verification options\n * @param jwkFetcher A function that can execute the fetch of the JWKS from the JWKS URI\n * @param transformJwkToKeyObjectFn A function that can transform a JWK into a crypto native key object\n * @returns Promise that resolves to the payload of the JWT\u2013\u2013if the JWT is valid, otherwise the promise rejects\n */\nasync function verifyDecomposedJwt(decomposedJwt, jwksUri, options, jwkFetcher, transformJwkToKeyObjectFn) {\n    const { header, headerB64, payload, payloadB64, signatureB64 } = decomposedJwt;\n    const jwk = await jwkFetcher(jwksUri, decomposedJwt);\n    validateJwtHeaderAndJwk(decomposedJwt.header, jwk);\n    // Transform the JWK to native key format, that can be used with verifySignature\n    const keyObject = await transformJwkToKeyObjectFn(jwk, header.alg, payload.iss);\n    // Verify the JWT signature\n    const valid = await nodeWebCompat.verifySignatureAsync({\n        jwsSigningInput: `${headerB64}.${payloadB64}`,\n        signature: signatureB64,\n        alg: header.alg,\n        keyObject,\n    });\n    if (!valid) {\n        throw new JwtInvalidSignatureError(\"Invalid signature\");\n    }\n    try {\n        validateJwtFields(payload, options);\n        if (options.customJwtCheck) {\n            await options.customJwtCheck({ header, payload, jwk });\n        }\n    }\n    catch (err) {\n        if (options.includeRawJwtInErrors && err instanceof JwtInvalidClaimError) {\n            throw err.withRawJwt(decomposedJwt);\n        }\n        throw err;\n    }\n    return payload;\n}\n/**\n * Verify a JWT synchronously, using a JWKS or JWK that has already been fetched\n *\n * @param jwt The JWT\n * @param jwkOrJwks The JWKS that includes the right JWK (indexed by kid). Alternatively, provide the right JWK directly\n * @param options Verification options\n * @param transformJwkToKeyObjectFn A function that can transform a JWK into a crypto native key object\n * @returns The (JSON parsed) payload of the JWT\u2013\u2013if the JWT is valid, otherwise an error is thrown\n */\nexport function verifyJwtSync(jwt, jwkOrJwks, options, transformJwkToKeyObjectFn = nodeWebCompat.transformJwkToKeyObjectSync) {\n    return verifyDecomposedJwtSync(decomposeUnverifiedJwt(jwt), jwkOrJwks, options, transformJwkToKeyObjectFn);\n}\n/**\n * Verify (synchronously) a JWT that is already decomposed (by function `decomposeUnverifiedJwt`)\n *\n * @param decomposedJwt The decomposed JWT\n * @param jwkOrJwks The JWKS that includes the right JWK (indexed by kid). Alternatively, provide the right JWK directly\n * @param options Verification options\n * @param transformJwkToKeyObjectFn A function that can transform a JWK into a crypto native key object\n * @returns The (JSON parsed) payload of the JWT\u2013\u2013if the JWT is valid, otherwise an error is thrown\n */\nfunction verifyDecomposedJwtSync(decomposedJwt, jwkOrJwks, options, transformJwkToKeyObjectFn) {\n    const { header, headerB64, payload, payloadB64, signatureB64 } = decomposedJwt;\n    let jwk;\n    if (isJwk(jwkOrJwks)) {\n        jwk = jwkOrJwks;\n    }\n    else if (isJwks(jwkOrJwks)) {\n        const locatedJwk = header.kid\n            ? findJwkInJwks(jwkOrJwks, header.kid)\n            : undefined;\n        if (!locatedJwk) {\n            throw new KidNotFoundInJwksError(`JWK for kid ${header.kid} not found in the JWKS`);\n        }\n        jwk = locatedJwk;\n    }\n    else {\n        throw new ParameterValidationError([\n            `Expected a valid JWK or JWKS (parsed as JavaScript object), but received: ${jwkOrJwks}.`,\n            \"If you're passing a JWKS URI, use the async verify() method instead, it will download and parse the JWKS for you\",\n        ].join());\n    }\n    validateJwtHeaderAndJwk(decomposedJwt.header, jwk);\n    // Transform the JWK to native key format, that can be used with verifySignature\n    const keyObject = transformJwkToKeyObjectFn(jwk, header.alg, payload.iss);\n    // Verify the JWT signature (JWS)\n    const valid = nodeWebCompat.verifySignatureSync({\n        jwsSigningInput: `${headerB64}.${payloadB64}`,\n        signature: signatureB64,\n        alg: header.alg,\n        keyObject,\n    });\n    if (!valid) {\n        throw new JwtInvalidSignatureError(\"Invalid signature\");\n    }\n    try {\n        validateJwtFields(payload, options);\n        if (options.customJwtCheck) {\n            const res = options.customJwtCheck({ header, payload, jwk });\n            assertIsNotPromise(res, () => new ParameterValidationError(\"Custom JWT checks must be synchronous but a promise was returned\"));\n        }\n    }\n    catch (err) {\n        if (options.includeRawJwtInErrors && err instanceof JwtInvalidClaimError) {\n            throw err.withRawJwt(decomposedJwt);\n        }\n        throw err;\n    }\n    return payload;\n}\n/**\n * Abstract class representing a verifier for JWTs\n *\n * A class is used, because there is state:\n * - The JWKS is fetched (downloaded) from the JWKS URI and cached in memory\n * - Verification properties at verifier level, are used as default options for individual verify calls\n *\n * When instantiating this class, relevant type parameters should be provided, for your concrete case:\n * @param SpecificVerifyProperties The verification options that you'll use\n * @param IssuerConfig The issuer config that you'll use (config options are used as default verification options)\n * @param MultiIssuer Verify multiple issuers (true) or just a single one (false)\n */\nexport class JwtVerifierBase {\n    constructor(verifyProperties, jwksCache = new SimpleJwksCache()) {\n        this.jwksCache = jwksCache;\n        this.issuersConfig = new Map();\n        this.publicKeyCache = new KeyObjectCache();\n        if (Array.isArray(verifyProperties)) {\n            if (!verifyProperties.length) {\n                throw new ParameterValidationError(\"Provide at least one issuer configuration\");\n            }\n            verifyProperties.forEach((prop, index) => {\n                if (this.issuersConfig.has(prop.issuer)) {\n                    throw new ParameterValidationError(`issuer ${prop.issuer} supplied multiple times`);\n                }\n                else if (prop.issuer === null && verifyProperties.length >= 2) {\n                    throw new ParameterValidationError(`issuer cannot be null when multiple issuers are supplied (at issuer: ${index})`);\n                }\n                this.issuersConfig.set(prop.issuer, this.withJwksUri(prop));\n            });\n        }\n        else {\n            this.issuersConfig.set(verifyProperties.issuer, this.withJwksUri(verifyProperties));\n        }\n    }\n    getIssuerConfig(issuer) {\n        if (this.issuersConfig.size === 1) {\n            issuer = this.issuersConfig.keys().next().value;\n        }\n        if (issuer === undefined) {\n            throw new ParameterValidationError(\"issuer must be provided\");\n        }\n        const config = this.issuersConfig.get(issuer);\n        if (!config) {\n            throw new ParameterValidationError(`issuer not configured: ${issuer}`);\n        }\n        return config;\n    }\n    /**\n     * This method loads a JWKS that you provide, into the JWKS cache, so that it is\n     * available for JWT verification. Use this method to speed up the first JWT verification\n     * (when the JWKS would otherwise have to be downloaded from the JWKS uri), or to provide the JWKS\n     * in case the JwtVerifier does not have internet access to download the JWKS\n     *\n     * @param jwksThe JWKS\n     * @param issuer The issuer for which you want to cache the JWKS\n     *  Supply this field, if you instantiated the JwtVerifier with multiple issuers\n     * @returns void\n     */\n    cacheJwks(...[jwks, issuer]) {\n        const issuerConfig = this.getIssuerConfig(issuer);\n        this.jwksCache.addJwks(issuerConfig.jwksUri, jwks);\n        this.publicKeyCache.clearCache(issuerConfig.issuer);\n    }\n    /**\n     * Hydrate the JWKS cache for (all of) the configured issuer(s).\n     * This will fetch and cache the latest and greatest JWKS for concerned issuer(s).\n     *\n     * @returns void\n     */\n    async hydrate() {\n        const jwksFetches = Array.from(this.issuersConfig.values()).map(({ jwksUri }) => this.jwksCache.getJwks(jwksUri));\n        await Promise.all(jwksFetches);\n    }\n    /**\n     * Verify (synchronously) a JWT.\n     *\n     * @param jwt The JWT, as string\n     * @param props Verification properties\n     * @returns The payload of the JWT\u2013\u2013if the JWT is valid, otherwise an error is thrown\n     */\n    verifySync(...[jwt, properties]) {\n        const { decomposedJwt, jwksUri, verifyProperties } = this.getVerifyParameters(jwt, properties);\n        return this.verifyDecomposedJwtSync(decomposedJwt, jwksUri, verifyProperties);\n    }\n    /**\n     * Verify (synchronously) an already decomposed JWT.\n     *\n     * @param decomposedJwt The decomposed Jwt\n     * @param jwk The JWK to verify the JWTs signature with\n     * @param verifyProperties The properties to use for verification\n     * @returns The payload of the JWT\u2013\u2013if the JWT is valid, otherwise an error is thrown\n     */\n    verifyDecomposedJwtSync(decomposedJwt, jwksUri, verifyProperties) {\n        const jwk = this.jwksCache.getCachedJwk(jwksUri, decomposedJwt);\n        return verifyDecomposedJwtSync(decomposedJwt, jwk, verifyProperties, this.publicKeyCache.transformJwkToKeyObjectSync.bind(this.publicKeyCache));\n    }\n    /**\n     * Verify (asynchronously) a JWT.\n     * This call is asynchronous, and the JWKS will be fetched from the JWKS uri,\n     * in case it is not yet available in the cache.\n     *\n     * @param jwt The JWT, as string\n     * @param props Verification properties\n     * @returns Promise that resolves to the payload of the JWT\u2013\u2013if the JWT is valid, otherwise the promise rejects\n     */\n    async verify(...[jwt, properties]) {\n        const { decomposedJwt, jwksUri, verifyProperties } = this.getVerifyParameters(jwt, properties);\n        return this.verifyDecomposedJwt(decomposedJwt, jwksUri, verifyProperties);\n    }\n    /**\n     * Verify (asynchronously) an already decomposed JWT.\n     *\n     * @param decomposedJwt The decomposed Jwt\n     * @param jwk The JWK to verify the JWTs signature with\n     * @param verifyProperties The properties to use for verification\n     * @returns The payload of the JWT\u2013\u2013if the JWT is valid, otherwise an error is thrown\n     */\n    verifyDecomposedJwt(decomposedJwt, jwksUri, verifyProperties) {\n        return verifyDecomposedJwt(decomposedJwt, jwksUri, verifyProperties, this.jwksCache.getJwk.bind(this.jwksCache), this.publicKeyCache.transformJwkToKeyObjectAsync.bind(this.publicKeyCache));\n    }\n    /**\n     * Get the verification parameters to use, by merging the issuer configuration,\n     * with the overriding properties that are now provided\n     *\n     * @param jwt: the JWT that is going to be verified\n     * @param verifyProperties: the overriding properties, that override the issuer configuration\n     * @returns The merged verification parameters\n     */\n    getVerifyParameters(jwt, verifyProperties) {\n        const decomposedJwt = decomposeUnverifiedJwt(jwt);\n        const issuerConfig = this.getIssuerConfig(decomposedJwt.payload.iss);\n        return {\n            decomposedJwt,\n            jwksUri: issuerConfig.jwksUri,\n            verifyProperties: {\n                ...issuerConfig,\n                ...verifyProperties,\n            },\n        };\n    }\n    /**\n     * Get issuer config with JWKS URI, by adding a default JWKS URI if needed\n     *\n     * @param config: the issuer config.\n     * @returns The config with JWKS URI\n     */\n    withJwksUri(config) {\n        if (config.jwksUri) {\n            return config;\n        }\n        const issuer = config.issuer;\n        if (!issuer) {\n            throw new ParameterValidationError(\"jwksUri must be provided for issuer null\");\n        }\n        const issuerUri = new URL(issuer).pathname.replace(/\\/$/, \"\");\n        return {\n            jwksUri: new URL(`${issuerUri}/.well-known/jwks.json`, issuer).href,\n            ...config,\n        };\n    }\n}\n/**\n * Class representing a verifier for JWTs\n */\nexport class JwtVerifier extends JwtVerifierBase {\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    static create(verifyProperties, additionalProperties) {\n        return new this(verifyProperties, additionalProperties?.jwksCache);\n    }\n}\n/**\n * Class representing a cache of public keys in native key object format\n *\n * Because it takes a bit of compute time to turn a JWK into native key object format,\n * we want to cache this computation.\n */\nexport class KeyObjectCache {\n    constructor(transformJwkToKeyObjectSyncFn = nodeWebCompat.transformJwkToKeyObjectSync, transformJwkToKeyObjectAsyncFn = nodeWebCompat.transformJwkToKeyObjectAsync) {\n        this.transformJwkToKeyObjectSyncFn = transformJwkToKeyObjectSyncFn;\n        this.transformJwkToKeyObjectAsyncFn = transformJwkToKeyObjectAsyncFn;\n        this.publicKeys = new Map();\n    }\n    /**\n     * Transform the JWK into a public key in native key object format.\n     * If the transformed JWK is already in the cache, it is returned from the cache instead.\n     *\n     * @param jwk: the JWK\n     * @param jwtHeaderAlg: the alg from the JWT header (used if absent on JWK)\n     * @param issuer: the issuer that uses the JWK for signing JWTs (used for caching the transformation)\n     * @returns the public key in native key object format\n     */\n    transformJwkToKeyObjectSync(jwk, jwtHeaderAlg, issuer) {\n        const alg = jwk.alg ?? jwtHeaderAlg;\n        if (!issuer || !jwk.kid || !alg) {\n            return this.transformJwkToKeyObjectSyncFn(jwk, alg, issuer);\n        }\n        const fromCache = this.publicKeys.get(issuer)?.get(jwk.kid)?.get(alg);\n        if (fromCache)\n            return fromCache;\n        const publicKey = this.transformJwkToKeyObjectSyncFn(jwk, alg, issuer);\n        this.putKeyObjectInCache(issuer, jwk.kid, alg, publicKey);\n        return publicKey;\n    }\n    /**\n     * Transform the JWK into a public key in native key object format (async).\n     * If the transformed JWK is already in the cache, it is returned from the cache instead.\n     *\n     * @param jwk: the JWK\n     * @param jwtHeaderAlg: the alg from the JWT header (used if absent on JWK)\n     * @param issuer: the issuer that uses the JWK for signing JWTs (used for caching the transformation)\n     * @returns the public key in native key object format\n     */\n    async transformJwkToKeyObjectAsync(jwk, jwtHeaderAlg, issuer) {\n        const alg = jwk.alg ?? jwtHeaderAlg;\n        if (!issuer || !jwk.kid || !alg) {\n            return this.transformJwkToKeyObjectAsyncFn(jwk, alg, issuer);\n        }\n        const fromCache = this.publicKeys.get(issuer)?.get(jwk.kid)?.get(alg);\n        if (fromCache)\n            return fromCache;\n        const publicKey = await this.transformJwkToKeyObjectAsyncFn(jwk, alg, issuer);\n        this.putKeyObjectInCache(issuer, jwk.kid, alg, publicKey);\n        return publicKey;\n    }\n    putKeyObjectInCache(issuer, kid, alg, publicKey) {\n        const cachedIssuer = this.publicKeys.get(issuer);\n        const cachedIssuerKid = cachedIssuer?.get(kid);\n        if (cachedIssuerKid) {\n            cachedIssuerKid.set(alg, publicKey);\n        }\n        else if (cachedIssuer) {\n            cachedIssuer.set(kid, new Map([[alg, publicKey]]));\n        }\n        else {\n            this.publicKeys.set(issuer, new Map([[kid, new Map([[alg, publicKey]])]]));\n        }\n    }\n    clearCache(issuer) {\n        this.publicKeys.delete(issuer);\n    }\n}\n", "// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { CognitoJwtInvalidClientIdError, CognitoJwtInvalidGroupError, CognitoJwtInvalidTokenUseError, JwtInvalidClaimError, ParameterValidationError, } from \"./error.js\";\nimport { JwtVerifierBase } from \"./jwt-verifier.js\";\nimport { assertStringArrayContainsString, assertStringEquals, assertStringArraysOverlap, } from \"./assert.js\";\n/**\n * Validate claims of a decoded Cognito JWT.\n * This function throws an error in case there's any validation issue.\n *\n * @param payload - The JSON parsed payload of the Cognito JWT\n * @param options - Validation options\n * @param options.groups - The cognito groups, of which at least one must be present in the JWT's cognito:groups claim\n * @param options.tokenUse - The required token use of the JWT: \"id\" or \"access\"\n * @param options.clientId - The required clientId of the JWT. May be an array of string, of which at least one must match\n * @returns void\n */\nexport function validateCognitoJwtFields(payload, options) {\n    // Check groups\n    if (options.groups != null) {\n        assertStringArraysOverlap(\"Cognito group\", payload[\"cognito:groups\"], options.groups, CognitoJwtInvalidGroupError);\n    }\n    // Check token use\n    assertStringArrayContainsString(\"Token use\", payload.token_use, [\"id\", \"access\"], CognitoJwtInvalidTokenUseError);\n    if (options.tokenUse !== null) {\n        if (options.tokenUse === undefined) {\n            throw new ParameterValidationError(\"tokenUse must be provided or set to null explicitly\");\n        }\n        assertStringEquals(\"Token use\", payload.token_use, options.tokenUse, CognitoJwtInvalidTokenUseError);\n    }\n    // Check clientId aka audience\n    if (options.clientId !== null) {\n        if (options.clientId === undefined) {\n            throw new ParameterValidationError(\"clientId must be provided or set to null explicitly\");\n        }\n        if (payload.token_use === \"id\") {\n            assertStringArrayContainsString('Client ID (\"audience\")', payload.aud, options.clientId, CognitoJwtInvalidClientIdError);\n        }\n        else {\n            assertStringArrayContainsString(\"Client ID\", payload.client_id, options.clientId, CognitoJwtInvalidClientIdError);\n        }\n    }\n}\n/**\n * Class representing a verifier for JWTs signed by Amazon Cognito\n */\nexport class CognitoJwtVerifier extends JwtVerifierBase {\n    constructor(props, jwksCache) {\n        const issuerConfig = Array.isArray(props)\n            ? props.map((p) => ({\n                ...p,\n                ...CognitoJwtVerifier.parseUserPoolId(p.userPoolId),\n                audience: null, // checked instead by validateCognitoJwtFields\n            }))\n            : {\n                ...props,\n                ...CognitoJwtVerifier.parseUserPoolId(props.userPoolId),\n                audience: null, // checked instead by validateCognitoJwtFields\n            };\n        super(issuerConfig, jwksCache);\n    }\n    /**\n     * Parse a User Pool ID, to extract the issuer and JWKS URI\n     *\n     * @param userPoolId The User Pool ID\n     * @returns The issuer and JWKS URI for the User Pool\n     */\n    static parseUserPoolId(userPoolId) {\n        // Disable safe regexp check as userPoolId is provided by developer, i.e. is not user input\n        // eslint-disable-next-line security/detect-unsafe-regex\n        const match = userPoolId.match(/^(?<region>(\\w+-)?\\w+-\\w+-\\d)+_\\w+$/);\n        if (!match) {\n            throw new ParameterValidationError(`Invalid Cognito User Pool ID: ${userPoolId}`);\n        }\n        const region = match.groups.region;\n        const issuer = `https://cognito-idp.${region}.amazonaws.com/${userPoolId}`;\n        return {\n            issuer,\n            jwksUri: `${issuer}/.well-known/jwks.json`,\n        };\n    }\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    static create(verifyProperties, additionalProperties) {\n        return new this(verifyProperties, additionalProperties?.jwksCache);\n    }\n    /**\n     * Verify (synchronously) a JWT that is signed by Amazon Cognito.\n     *\n     * @param jwt The JWT, as string\n     * @param props Verification properties\n     * @returns The payload of the JWT\u2013\u2013if the JWT is valid, otherwise an error is thrown\n     */\n    verifySync(...[jwt, properties]) {\n        const { decomposedJwt, jwksUri, verifyProperties } = this.getVerifyParameters(jwt, properties);\n        this.verifyDecomposedJwtSync(decomposedJwt, jwksUri, verifyProperties);\n        try {\n            validateCognitoJwtFields(decomposedJwt.payload, verifyProperties);\n        }\n        catch (err) {\n            if (verifyProperties.includeRawJwtInErrors &&\n                err instanceof JwtInvalidClaimError) {\n                throw err.withRawJwt(decomposedJwt);\n            }\n            throw err;\n        }\n        return decomposedJwt.payload;\n    }\n    /**\n     * Verify (asynchronously) a JWT that is signed by Amazon Cognito.\n     * This call is asynchronous, and the JWKS will be fetched from the JWKS uri,\n     * in case it is not yet available in the cache.\n     *\n     * @param jwt The JWT, as string\n     * @param props Verification properties\n     * @returns Promise that resolves to the payload of the JWT\u2013\u2013if the JWT is valid, otherwise the promise rejects\n     */\n    async verify(...[jwt, properties]) {\n        const { decomposedJwt, jwksUri, verifyProperties } = this.getVerifyParameters(jwt, properties);\n        await this.verifyDecomposedJwt(decomposedJwt, jwksUri, verifyProperties);\n        try {\n            validateCognitoJwtFields(decomposedJwt.payload, verifyProperties);\n        }\n        catch (err) {\n            if (verifyProperties.includeRawJwtInErrors &&\n                err instanceof JwtInvalidClaimError) {\n                throw err.withRawJwt(decomposedJwt);\n            }\n            throw err;\n        }\n        return decomposedJwt.payload;\n    }\n    /**\n     * This method loads a JWKS that you provide, into the JWKS cache, so that it is\n     * available for JWT verification. Use this method to speed up the first JWT verification\n     * (when the JWKS would otherwise have to be downloaded from the JWKS uri), or to provide the JWKS\n     * in case the JwtVerifier does not have internet access to download the JWKS\n     *\n     * @param jwks The JWKS\n     * @param userPoolId The userPoolId for which you want to cache the JWKS\n     *  Supply this field, if you instantiated the CognitoJwtVerifier with multiple userPoolIds\n     * @returns void\n     */\n    cacheJwks(...[jwks, userPoolId]) {\n        let issuer;\n        if (userPoolId !== undefined) {\n            issuer = CognitoJwtVerifier.parseUserPoolId(userPoolId).issuer;\n        }\n        else if (Array.from(this.issuersConfig).length > 1) {\n            throw new ParameterValidationError(\"userPoolId must be provided\");\n        }\n        const issuerConfig = this.getIssuerConfig(issuer);\n        super.cacheJwks(jwks, issuerConfig.issuer);\n    }\n}\n"],
  "mappings": "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",
  "names": ["data", "JwtSignatureAlgorithmHashNames", "fetch"]
}
